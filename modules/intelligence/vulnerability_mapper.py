# shadowfox/ai/vulnerability_mapper.py

import json
import numpy as np
from typing import Dict, List, Tuple, Any, Optional
from dataclasses import dataclass
from enum import Enum
import logging
from datetime import datetime
import sqlite3

class VulnSeverity(Enum):
    CRITICAL = 4
    HIGH = 3
    MEDIUM = 2
    LOW = 1
    INFO = 0

class AttackVector(Enum):
    NETWORK = "network"
    ADJACENT = "adjacent"
    LOCAL = "local"
    PHYSICAL = "physical"

@dataclass
class VulnerabilitySignature:
    """Potpis ranjivosti za AI prepoznavanje"""
    vuln_type: str
    indicators: List[str]
    severity: VulnSeverity
    attack_vector: AttackVector
    prerequisites: List[str]
    confidence_threshold: float
    payloads: List[str]

@dataclass
class AttackPath:
    """Putanja napada sa koracima i verovatnoćom uspeha"""
    path_id: str
    steps: List[Dict]
    success_probability: float
    estimated_time: int  # u minutima
    required_tools: List[str]
    stealth_level: int  # 1-5, gde je 5 najstealthier

class AIVulnerabilityMapper:
    """
    AI sistem za mapiranje ranjivosti i kreiranje strategijskih putanja napada
    """
    
    def __init__(self, operator):
        self.operator = operator
        self.logger = logging.getLogger('AIVulnMapper')
        
        # Knowledge base ranjivosti
        self.vulnerability_signatures = self._load_vulnerability_signatures()
        
        # Strategijski modeli
        self.attack_patterns = self._load_attack_patterns()
        
        # AI scoring weights
        self.scoring_weights = {
            'severity': 0.25,
            'exploitability': 0.20,
            'stealth': 0.15,
            'success_probability': 0.25,
            'time_efficiency': 0.15
        }
    
    def _load_vulnerability_signatures(self) -> List[VulnerabilitySignature]:
        """Učitava bazu potpisa ranjivosti"""
        signatures = [
            # SQL Injection signatures
            VulnerabilitySignature(
                vuln_type="SQL_INJECTION",
                indicators=["error in your SQL syntax", "mysql_fetch", "ORA-", "Microsoft JET Database",
                          "sqlite_master", "pg_sleep", "waitfor delay", "benchmark("],
                severity=VulnSeverity.HIGH,
                attack_vector=AttackVector.NETWORK,
                prerequisites=["web_form", "url_parameters", "headers"],
                confidence_threshold=0.8,
                payloads=["' OR '1'='1", "'; DROP TABLE", "1' UNION SELECT", "' AND SLEEP(5)--"]
            ),
            
            # XSS signatures
            VulnerabilitySignature(
                vuln_type="XSS_REFLECTED",
                indicators=["<script>", "javascript:", "onload=", "onerror=", "eval("],
                severity=VulnSeverity.MEDIUM,
                attack_vector=AttackVector.NETWORK,
                prerequisites=["user_input", "insufficient_filtering"],
                confidence_threshold=0.7,
                payloads=["<script>alert('XSS')</script>", "javascript:alert(1)", 
                         "<img src=x onerror=alert(1)>", "<svg onload=alert(1)>"]
            ),
            
            # SSRF signatures
            VulnerabilitySignature(
                vuln_type="SSRF",
                indicators=["localhost", "127.0.0.1", "internal network", "timeout", "connection refused"],
                severity=VulnSeverity.HIGH,
                attack_vector=AttackVector.NETWORK,
                prerequisites=["url_parameter", "file_upload", "webhook"],
                confidence_threshold=0.75,
                payloads=["http://localhost:22", "http://169.254.169.254/", "file:///etc/passwd"]
            ),
            
            # LFI signatures
            VulnerabilitySignature(
                vuln_type="LFI",
                indicators=["root:x:0:0", "/etc/passwd", "boot.ini", "win.ini", "[boot loader]"],
                severity=VulnSeverity.HIGH,
                attack_vector=AttackVector.NETWORK,
                prerequisites=["file_parameter", "path_traversal"],
                confidence_threshold=0.9,
                payloads=["../../../etc/passwd", "....//....//etc/passwd", "/etc/passwd%00"]
            ),
            
            # Authentication bypass
            VulnerabilitySignature(
                vuln_type="AUTH_BYPASS",
                indicators=["admin panel", "unauthorized access", "session", "login successful"],
                severity=VulnSeverity.CRITICAL,
                attack_vector=AttackVector.NETWORK,
                prerequisites=["login_form", "weak_session"],
                confidence_threshold=0.85,
                payloads=["admin:admin", "' OR 1=1--", "admin'--", "bypass"]
            ),
            
            # XXE signatures
            VulnerabilitySignature(
                vuln_type="XXE",
                indicators=["xml", "<!DOCTYPE", "ENTITY", "SYSTEM", "file://"],
                severity=VulnSeverity.HIGH,
                attack_vector=AttackVector.NETWORK,
                prerequisites=["xml_input", "xml_parser"],
                confidence_threshold=0.8,
                payloads=['<!DOCTYPE test [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>']
            )
        ]
        
        return signatures
    
    def _load_attack_patterns(self) -> Dict[str, List[Dict]]:
        """Učitava poznate obrasce napada"""
        return {
            "web_app_standard": [
                {"step": "recon", "tools": ["ReconAgent"], "time": 5},
                {"step": "form_discovery", "tools": ["ReconAgent"], "time": 3},
                {"step": "parameter_fuzzing", "tools": ["MutationEngine"], "time": 10},
                {"step": "vulnerability_testing", "tools": ["SmartShadowAgent"], "time": 15},
                {"step": "exploitation", "tools": ["SmartShadowAgent"], "time": 20}
            ],
            
            "api_focused": [
                {"step": "endpoint_discovery", "tools": ["ReconAgent"], "time": 8},
                {"step": "authentication_test", "tools": ["SmartShadowAgent"], "time": 5},
                {"step": "parameter_manipulation", "tools": ["MutationEngine"], "time": 12},
                {"step": "injection_testing", "tools": ["SmartShadowAgent"], "time": 18}
            ],
            
            "stealth_mode": [
                {"step": "passive_recon", "tools": ["ReconAgent"], "time": 10},
                {"step": "slow_enumeration", "tools": ["TrafficShaper"], "time": 30},
                {"step": "targeted_testing", "tools": ["SmartShadowAgent"], "time": 25}
            ]
        }
    
    def analyze_target_surface(self, recon_data: Dict) -> Dict[str, Any]:
        """
        Analizira napadnu površinu i kreira vulnerability map
        """
        self.logger.info("Početak AI analize napadne površine")
        
        analysis = {
            "target_url": recon_data.get("target_url"),
            "timestamp": datetime.now().isoformat(),
            "identified_vulnerabilities": [],
            "attack_surface": {},
            "risk_score": 0.0,
            "recommended_vectors": [],
            "strategic_paths": []
        }
        
        # 1. Identifikuj potencijalne ranjivosti
        vulnerabilities = self._identify_vulnerabilities(recon_data)
        analysis["identified_vulnerabilities"] = vulnerabilities
        
        # 2. Mapiranje napadne površine
        attack_surface = self._map_attack_surface(recon_data, vulnerabilities)
        analysis["attack_surface"] = attack_surface
        
        # 3. Kalkulacija rizika
        analysis["risk_score"] = self._calculate_risk_score(vulnerabilities, attack_surface)
        
        # 4. AI preporuke za vektore napada
        analysis["recommended_vectors"] = self._recommend_attack_vectors(vulnerabilities, attack_surface)
        
        # 5. Generiši strategijske putanje
        analysis["strategic_paths"] = self._generate_strategic_paths(analysis)
        
        # Loguj rezultate
        self.operator.log_agent_action("AIVulnMapper", "surface_analyzed", {
            "vulnerabilities_found": len(vulnerabilities),
            "risk_score": analysis["risk_score"],
            "recommended_vectors": len(analysis["recommended_vectors"])
        })
        
        return analysis
    
    def _identify_vulnerabilities(self, recon_data: Dict) -> List[Dict]:
        """Identifikuje ranjivosti na osnovu recon podataka"""
        found_vulnerabilities = []
        
        # Analiziraj teknologije
        technologies = recon_data.get("technologies", {})
        headers = recon_data.get("headers", {})
        endpoints = recon_data.get("endpoints", [])
        forms = recon_data.get("forms", [])
        
        for signature in self.vulnerability_signatures:
            confidence = 0.0
            evidence = []
            
            # Proveri indikatore u različitim delovima recon podataka
            for indicator in signature.indicators:
                # Tehnologije
                if any(indicator.lower() in tech.lower() for tech in technologies.keys()):
                    confidence += 0.3
                    evidence.append(f"Technology: {indicator}")
                
                # Headers
                header_text = str(headers).lower()
                if indicator.lower() in header_text:
                    confidence += 0.4
                    evidence.append(f"Header: {indicator}")
                
                # Endpoints
                if any(indicator.lower() in endpoint.lower() for endpoint in endpoints):
                    confidence += 0.2
                    evidence.append(f"Endpoint: {indicator}")
            
            # Proveri prerequisite
            prereq_score = self._check_prerequisites(signature.prerequisites, recon_data)
            confidence += prereq_score * 0.3
            
            # Normalizuj confidence
            confidence = min(confidence, 1.0)
            
            if confidence >= signature.confidence_threshold:
                found_vulnerabilities.append({
                    "type": signature.vuln_type,
                    "severity": signature.severity.name,
                    "confidence": confidence,
                    "evidence": evidence,
                    "attack_vector": signature.attack_vector.value,
                    "payloads": signature.payloads,
                    "prerequisites_met": prereq_score > 0.5
                })
        
        return found_vulnerabilities
    
    def _check_prerequisites(self, prerequisites: List[str], recon_data: Dict) -> float:
        """Proverava da li su ispunjeni prerequisiti za ranjivost"""
        if not prerequisites:
            return 1.0
        
        met_count = 0
        total_count = len(prerequisites)
        
        for prereq in prerequisites:
            if prereq == "web_form" and recon_data.get("forms"):
                met_count += 1
            elif prereq == "url_parameters" and "?" in recon_data.get("target_url", ""):
                met_count += 1
            elif prereq == "user_input" and recon_data.get("forms"):
                met_count += 1
            elif prereq == "xml_input":
                # Pretpostavi XML input ako ima forme ili API endpoints
                if recon_data.get("forms") or any("api" in ep for ep in recon_data.get("endpoints", [])):
                    met_count += 1
        
        return met_count / total_count
    
    def _map_attack_surface(self, recon_data: Dict, vulnerabilities: List[Dict]) -> Dict:
        """Mapira napadnu površinu"""
        attack_surface = {
            "entry_points": [],
            "technologies": list(recon_data.get("technologies", {}).keys()),
            "open_ports": recon_data.get("ports", {}).get("open_ports", []),
            "forms_count": len(recon_data.get("forms", [])),
            "endpoints_count": len(recon_data.get("endpoints", [])),
            "security_headers": {
                "present": [],
                "missing": recon_data.get("headers", {}).get("missing_security", [])
            }
        }
        
        # Identifikuj entry points na osnovu formi i endpoints
        for form in recon_data.get("forms", []):
            attack_surface["entry_points"].append({
                "type": "form",
                "method": form.get("method", "GET"),
                "action": form.get("action"),
                "inputs": len(form.get("inputs", []))
            })
        
        for endpoint in recon_data.get("endpoints", []):
            attack_surface["entry_points"].append({
                "type": "endpoint",
                "url": endpoint,
                "method": "GET"  # Pretpostavi GET, može se proširiti
            })
        
        return attack_surface
    
    def _calculate_risk_score(self, vulnerabilities: List[Dict], attack_surface: Dict) -> float:
        """Kalkuliše ukupni risk score"""
        base_score = 0.0
        
        # Score na osnovu ranjivosti
        for vuln in vulnerabilities:
            severity_scores = {"CRITICAL": 10, "HIGH": 7, "MEDIUM": 4, "LOW": 2, "INFO": 1}
            vuln_score = severity_scores.get(vuln["severity"], 1) * vuln["confidence"]
            base_score += vuln_score
        
        # Amplifikator na osnovu napadne površine
        surface_multiplier = 1.0
        surface_multiplier += len(attack_surface["entry_points"]) * 0.1
        surface_multiplier += len(attack_surface["open_ports"]) * 0.05
        surface_multiplier += len(attack_surface["security_headers"]["missing"]) * 0.1
        
        final_score = (base_score * surface_multiplier) / 10.0  # Normalizuj na 0-10
        return min(final_score, 10.0)
    
    def _recommend_attack_vectors(self, vulnerabilities: List[Dict], attack_surface: Dict) -> List[Dict]:
        """AI preporuke za najbolje vektore napada"""
        recommendations = []
        
        # Sortuj ranjivosti po prioritetu
        vuln_priority = sorted(vulnerabilities, 
                             key=lambda x: (
                                 {"CRITICAL": 4, "HIGH": 3, "MEDIUM": 2, "LOW": 1}.get(x["severity"], 0),
                                 x["confidence"]
                             ), reverse=True)
        
        for vuln in vuln_priority[:5]:  # Top 5 ranjivosti
            recommendation = {
                "vulnerability_type": vuln["type"],
                "severity": vuln["severity"],
                "confidence": vuln["confidence"],
                "attack_method": self._get_attack_method(vuln["type"]),
                "estimated_success": self._estimate_success_rate(vuln, attack_surface),
                "stealth_rating": self._calculate_stealth_rating(vuln["type"]),
                "payloads": vuln["payloads"][:3]  # Top 3 payloads
            }
            recommendations.append(recommendation)
        
        return recommendations
    
    def _get_attack_method(self, vuln_type: str) -> str:
        """Vraća preporučeni metod napada za tip ranjivosti"""
        methods = {
            "SQL_INJECTION": "Parameter manipulation with SQL payloads",
            "XSS_REFLECTED": "User input injection with JavaScript",
            "SSRF": "URL parameter manipulation to internal resources",
            "LFI": "File path manipulation for directory traversal",
            "AUTH_BYPASS": "Authentication mechanism exploitation",
            "XXE": "XML entity injection for file disclosure"
        }
        return methods.get(vuln_type, "Generic payload injection")
    
    def _estimate_success_rate(self, vulnerability: Dict, attack_surface: Dict) -> float:
        """Procenjuje verovatnoću uspeha napada"""
        base_rate = vulnerability["confidence"]
        
        # Faktor napadne površine
        if attack_surface["forms_count"] > 0:
            base_rate += 0.1
        
        # Faktor sigurnosnih zaglavlja
        missing_security = len(attack_surface["security_headers"]["missing"])
        base_rate += missing_security * 0.05
        
        # Faktor tehnologija (neke su ranjivije)
        risky_tech = ["WordPress", "Drupal", "PHP", "ASP.NET"]
        if any(tech in attack_surface["technologies"] for tech in risky_tech):
            base_rate += 0.1
        
        return min(base_rate, 1.0)
    
    def _calculate_stealth_rating(self, vuln_type: str) -> int:
        """Kalkuliše stealth rating (1-5, 5 je najstealthier)"""
        stealth_ratings = {
            "SQL_INJECTION": 3,  # Mogu se detektovati WAF-om
            "XSS_REFLECTED": 4,  # Teži za detektovanje
            "SSRF": 2,           # Često logovan
            "LFI": 3,            # Umeren stealth
            "AUTH_BYPASS": 1,    # Visoko vidljiv
            "XXE": 4             # Teži za detektovanje
        }
        return stealth_ratings.get(vuln_type, 3)
    
    def _generate_strategic_paths(self, analysis: Dict) -> List[AttackPath]:
        """Generiše optimalne strategijske putanje napada"""
        paths = []
        
        vulnerabilities = analysis["identified_vulnerabilities"]
        if not vulnerabilities:
            return paths
        
        # Generiši različite strategije
        strategies = ["aggressive", "balanced", "stealth"]
        
        for strategy in strategies:
            path = self._create_attack_path(strategy, vulnerabilities, analysis)
            if path:
                paths.append(path)
        
        # Sortiraj po success probability
        paths.sort(key=lambda x: x.success_probability, reverse=True)
        
        return paths[:3]  # Vrati top 3 putanje
    
    def _create_attack_path(self, strategy: str, vulnerabilities: List[Dict], analysis: Dict) -> Optional[AttackPath]:
        """Kreira specifičnu attack path za datu strategiju"""
        
        if strategy == "aggressive":
            # Brza, direktna putanja sa najvećom verovatnoćom
            top_vuln = max(vulnerabilities, key=lambda x: x["confidence"])
            steps = [
                {"agent": "ReconAgent", "action": "quick_scan", "time": 2},
                {"agent": "MutationEngine", "action": "generate_payloads", "time": 3, "target": top_vuln["type"]},
                {"agent": "SmartShadowAgent", "action": "rapid_testing", "time": 10},
                {"agent": "ProofCollector", "action": "collect_evidence", "time": 2}
            ]
            return AttackPath(
                path_id="aggressive_path",
                steps=steps,
                success_probability=top_vuln["confidence"] * 0.9,
                estimated_time=17,
                required_tools=["ReconAgent", "MutationEngine", "SmartShadowAgent", "ProofCollector"],
                stealth_level=2
            )
            
        elif strategy == "balanced":
            # Balansirana putanja sa umerenim tempom
            avg_confidence = sum(v["confidence"] for v in vulnerabilities) / len(vulnerabilities)
            steps = [
                {"agent": "ReconAgent", "action": "thorough_scan", "time": 5},
                {"agent": "MutationEngine", "action": "comprehensive_payloads", "time": 8},
                {"agent": "TrafficShaper", "action": "moderate_shaping", "time": 2},
                {"agent": "SmartShadowAgent", "action": "systematic_testing", "time": 20},
                {"agent": "AIEvaluator", "action": "analyze_responses", "time": 5},
                {"agent": "ProofCollector", "action": "document_findings", "time": 5}
            ]
            return AttackPath(
                path_id="balanced_path",
                steps=steps,
                success_probability=avg_confidence * 0.85,
                estimated_time=45,
                required_tools=["ReconAgent", "MutationEngine", "TrafficShaper", "SmartShadowAgent", "AIEvaluator", "ProofCollector"],
                stealth_level=3
            )
            
        elif strategy == "stealth":
            # Spora, neprimećena putanja
            stealth_vulns = [v for v in vulnerabilities if self._calculate_stealth_rating(v["type"]) >= 4]
            if not stealth_vulns:
                return None
                
            steps = [
                {"agent": "ReconAgent", "action": "passive_recon", "time": 10},
                {"agent": "TrafficShaper", "action": "maximum_stealth", "time": 5},
                {"agent": "MutationEngine", "action": "stealth_payloads", "time": 15},
                {"agent": "SmartShadowAgent", "action": "slow_testing", "time": 45},
                {"agent": "AIEvaluator", "action": "careful_analysis", "time": 10},
                {"agent": "ProofCollector", "action": "minimal_evidence", "time": 3}
            ]
            
            avg_stealth_confidence = sum(v["confidence"] for v in stealth_vulns) / len(stealth_vulns)
            return AttackPath(
                path_id="stealth_path",
                steps=steps,
                success_probability=avg_stealth_confidence * 0.7,  # Niža zbog opreznosti
                estimated_time=88,
                required_tools=["ReconAgent", "TrafficShaper", "MutationEngine", "SmartShadowAgent", "AIEvaluator", "ProofCollector"],
                stealth_level=5
            )
        
        return None
    
    def select_optimal_path(self, strategic_paths: List[AttackPath], preferences: Dict = None) -> Optional[AttackPath]:
        """
        Selektuje optimalnu putanju na osnovu korisničkih preferencija
        """
        if not strategic_paths:
            return None
        
        # Default preferences ako nisu zadati
        if not preferences:
            preferences = {
                "speed_priority": 0.3,
                "stealth_priority": 0.3,
                "success_priority": 0.4
            }
        
        best_path = None
        best_score = -1
        
        for path in strategic_paths:
            # Normalizuj faktore (0-1)
            speed_score = 1.0 - (path.estimated_time / 120.0)  # Pretpostavi max 2h
            stealth_score = path.stealth_level / 5.0
            success_score = path.success_probability
            
            # Izračunaj kompozitni score
            composite_score = (
                speed_score * preferences["speed_priority"] +
                stealth_score * preferences["stealth_priority"] +
                success_score * preferences["success_priority"]
            )
            
            if composite_score > best_score:
                best_score = composite_score
                best_path = path
        
        return best_path

# Test funkcionalnosti
if __name__ == "__main__":
    from operator import ShadowFoxOperator
    
    # Test sa mock recon podacima
    mock_recon = {
        "target_url": "https://example.com",
        "technologies": {"PHP": True, "MySQL": True},
        "headers": {"missing_security": ["x-frame-options", "content-security-policy"]},
        "endpoints": ["/admin", "/api/users"],
        "forms": [{"method": "POST", "action": "/login", "inputs": [{"name": "username"}, {"name": "password"}]}],
        "ports": {"open_ports": [80, 443, 22]}
    }
    
    op = ShadowFoxOperator()
    mapper = AIVulnerabilityMapper(op)
    
    analysis = mapper.analyze_target_surface(mock_recon)
    print(json.dumps(analysis, indent=2, default=str))
